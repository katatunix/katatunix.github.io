[{"categories":["Apps"],"content":" Tải phần mềm GoldenDict: Bản Windows: https://drive.google.com/file/d/1RSU72JfEYkAuAuqZWNzUTYW_8p8MBDzI/view?usp=drive_link Bản macOS (Apple Silicon): https://github.com/xiaoyifang/goldendict-ng/releases/download/v24.09.1-Release.ca9dd133/GoldenDict-ng-24.09.1-Qt6.7.2-macOS-arm64.dmg Sau khi tải xong: Đối với Windows: giải nén và chạy file goldendict.exe. Đối với macOS: cài đặt như thông thường, rồi chạy app GoldenDict-ng lên. Tải dữ liệu từ điển (Longman và Lạc Việt): https://drive.google.com/file/d/1nU50Lhrohi6AP3OK2GLcwoivbMZNwhx-/view?usp=drive_link Giải nén file dữ liệu vào một thư mục cố định trên ổ cứng. Quay lại GoldenDict: Vào menu Edit/Dictionaries. Nhấn nút Add để chọn thư mục dữ liệu từ điển ở bước 5. Tick vào ô Recursive. Nhấn nút Rescan now. OK. Tận hưởng nhé ạ. ","date":"December 03, 2024","objectID":"/posts/2024/12-03-huong-dan-cai-dat-goldendict/:0:0","tags":["GoldenDict"],"title":"Hướng dẫn cài đặt GoldenDict nhé ạ","uri":"/posts/2024/12-03-huong-dan-cai-dat-goldendict/"},{"categories":["Cryptography"],"content":"Chữ ký điện tử được sử dụng như thế nào trong hành chính công","date":"April 14, 2023","objectID":"/posts/2023/04-14-nom-na-ve-chu-ky-dien-tu/","tags":["DigitalSignature","AsymmetricCryptography"],"title":"Nôm na về chữ ký điện tử","uri":"/posts/2023/04-14-nom-na-ve-chu-ky-dien-tu/"},{"categories":["Cryptography"],"content":"Nhân dịp người dân Hà Nội được cấp chữ ký số miễn phí trên phố đi bộ hồ Gươm, cùng tìm hiểu – hết sức nôm na – về chữ ký điện tử. Chữ ký điện tử là một ứng dụng của mật mã hoá bất đối xứng asymmetric cryptography. Đại khái là, mỗi người sở hữu một cặp private key + public key. Private key phải giữ bí mật. Public key thì công khai thoải mái. Khi có một văn bản cần ký: Người đó dùng private key để tạo chữ ký cho văn bản đó theo một thuật toán xác định (ví dụ RS256). Người khác nhận được văn bản + chữ ký + public key + tên thuật toán, sẽ kiểm chứng được đây đúng là chữ ký được sinh ra bởi chủ sở hữu của public key đó cho văn bản đó. Thuật toán mật mã đảm bảo: Chỉ có người biết private key tương ứng với public key đó mới tạo được chữ ký đó, cho văn bản đó. Cùng một người (cùng một private key) thì với văn bản khác nhau sẽ sinh ra chữ ký khác nhau. Nghĩa là, chữ ký là duy nhất với mỗi văn bản, do đó ko thể dùng lại cho văn bản khác. Ngoài ra, hai văn bản khác nhau dù tí tẹo sẽ sinh ra hai chữ ký khác hẳn nhau nhằm chống kẻ gian tận dụng chữ ký cũ đoán (giả mạo) chữ ký mới. Vấn đề còn lại là phải có một cơ quan uy tín chứng thực quyền sở hữu các public key trên tư cách công dân. Ví dụ public key abcd là của ông Nguyễn Văn A có số CCCD là xyzw. Về nguyên tắc cơ quan này ko được giữ private key, vì nếu vậy họ có thể ký hộ người dân nếu muốn. Người dân chịu trách nhiệm lưu giữ private key, có thể trong usb, phone, ổ cứng… (thím nào hay đọc tin tức về bitcoin sẽ thấy câu chuyện tương tự). Người dân sẽ phải đăng ký public key với cơ quan nói trên, và chứng minh là mình có private key tương ứng. Tuy nhiên, thực tế để đơn giản cho người dân, thì cơ quan ấy sẽ tự chỉ định thuật toán, tạo hộ các key, đăng ký luôn, rồi cung cấp các key, cũng như các thao tác liên quan cho người dân – thông qua app/web. Về căn bản là vậy. ","date":"April 14, 2023","objectID":"/posts/2023/04-14-nom-na-ve-chu-ky-dien-tu/:0:0","tags":["DigitalSignature","AsymmetricCryptography"],"title":"Nôm na về chữ ký điện tử","uri":"/posts/2023/04-14-nom-na-ve-chu-ky-dien-tu/"},{"categories":["Cryptocurrency"],"content":"Hiểu cho đúng về nghĩa của từ \"kiểm soát\" trong ngữ cảnh Bitcoin","date":"May 19, 2021","objectID":"/posts/2021/05-19-kiem-soat-bitcoin/","tags":["Bitcoin"],"title":"\"Kiểm soát\" Bitcoin?","uri":"/posts/2021/05-19-kiem-soat-bitcoin/"},{"categories":["Cryptocurrency"],"content":"Sau sự kiện elon musk thao túng giá bitcoin, rất nhiều bạn mỉa mai phàn nàn: “mục tiêu của bitcoin là để không bị chính phủ kiểm soát, nhưng rốt cục lại bị cá nhân/mập kiểm soát, hố hố”. Cần phải hiểu đúng nghĩa của từ “kiểm soát” trong ngữ cảnh này. “Kiểm soát” ở đây không phải là về “giá”, mà là về (1) phát hành và (2) lưu thông. ","date":"May 19, 2021","objectID":"/posts/2021/05-19-kiem-soat-bitcoin/:0:0","tags":["Bitcoin"],"title":"\"Kiểm soát\" Bitcoin?","uri":"/posts/2021/05-19-kiem-soat-bitcoin/"},{"categories":["Cryptocurrency"],"content":"Phát hành (issue) Giao thức bitcoin đã quy định rõ tổng cộng có 21 triệu bitcoin được phát hành theo một tần suất xác định. Dĩ nhiên, quy định do con người đặt ra thì con người cũng sửa đổi được. Vấn đề là cái “con người” ấy phải thuyết phục được “toàn bộ con người”. Bitcoin – với lịch sử hoạt động lâu nhất và lực lượng miner hùng hậu nhất – đang có tính decentralized rất cao. Đến bố của elon cũng không sửa giao thức được. ","date":"May 19, 2021","objectID":"/posts/2021/05-19-kiem-soat-bitcoin/:0:1","tags":["Bitcoin"],"title":"\"Kiểm soát\" Bitcoin?","uri":"/posts/2021/05-19-kiem-soat-bitcoin/"},{"categories":["Cryptocurrency"],"content":"Lưu thông (circulation) Bitcoin được chuyển đi / nhận về thông qua một cơ chế hết sức đặc biệt và có thể nói là tinh tuý của nó: đào. Một lần nữa decentralization phát huy tác dụng: không có chuyện toàn bộ thợ đào trên thế giới rủ nhau đi nghỉ hoặc cấu kết từ chối giao dịch. Ngoài mặt có thể đồng ý nghỉ nhưng ở nhà lén đào vì mấy thằng kia nghỉ hết thì mình đào mới thơm. Dưới đây là abstract của bitcoin white paper, mỗi một chữ đều là lời vàng ngọc. Bitcoin whitepaper abstract A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. Digital signatures provide part of the solution, but the main benefits are lost if a trusted third party is still required to prevent double-spending. We propose a solution to the double-spending problem using a peer-to-peer network. The network timestamps transactions by hashing them into an ongoing chain of hash-based proof-of-work, forming a record that cannot be changed without redoing the proof-of-work. The longest chain not only serves as proof of the sequence of events witnessed, but proof that it came from the largest pool of CPU power. As long as a majority of CPU power is controlled by nodes that are not cooperating to attack the network, they’ll generate the longest chain and outpace attackers. The network itself requires minimal structure. Messages are broadcast on a best effort basis, and nodes can leave and rejoin the network at will, accepting the longest proof-of-work chain as proof of what happened while they were gone. Tôi ngáo Bitcoin, ai cho tôi cũng lấy. ","date":"May 19, 2021","objectID":"/posts/2021/05-19-kiem-soat-bitcoin/:0:2","tags":["Bitcoin"],"title":"\"Kiểm soát\" Bitcoin?","uri":"/posts/2021/05-19-kiem-soat-bitcoin/"},{"categories":["Programming"],"content":"Yet another explanation on monads in the context of functional programming","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"I know, I know, the world does not need yet another explanation on monads. There have been a lot of related articles you can find on the Internet. Still, most of them are so math-intensive that we as software developers (we aren’t good at math) don’t want to read. So please give me a try to explain monads to you. I think they are worth knowing about. No math knowledge is required. What I want from you is just a basic knowledge of programming with types and functions. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:0:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"Motivation Let’s say we have a collection of functions, each receives something of some type and returns something of some type. We denote them as: f1: A -\u003e B f2: B -\u003e C f3: C -\u003e D f4: D -\u003e E Since these functions are type compatible – the output type of a function is the same with the input type of the next function – they are easily composable. For example, we can compose f1 and f2 to get a new function g with type A -\u003e C, like this: g = compose f1 f2 Or we can use the operator \u003e\u003e: g = f1 \u003e\u003e f2 One day, due to requirement changes, we modify the output types of some functions: f1: A -\u003e M\u003cB\u003e f2: B -\u003e M\u003cC\u003e f3: C -\u003e M\u003cD\u003e f4: D -\u003e E where M\u003c'T\u003e is some variant type of 'T, for example, Option\u003c'T\u003e, or Async\u003c'T\u003e. Roughly speaking, M\u003c'T\u003e is a “wrapper” of 'T. Note The notion 'T depicts a generic type with name T. This situation is very common. Initially, the requirements of our software are simple; so, for example, f1 can return a value of type B directly. Later, requirements are changed, we recognize that in some cases f1 can fail to return a value of B and needs to return something like None or Nothing. In this example, the type Option\u003c'T\u003e is used, the f1 function should return a value of type Option\u003cB\u003e. Now, the problem is that these functions are not composable anymore. What should we do? ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:1:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"The magicCompose function Assume that we could compose f1 and f2 by using a magicCompose function, to get a function g of type A -\u003e M\u003cC\u003e, like this: g = magicCompose f1 f2 Let’s build magicCompose and we will see that it is not magic at all. The magicCompose function receives f1 and f2 as input, its job is to produce a new function with type (a: A) -\u003e M\u003cC\u003e. Firstly, a is always passed to f1, and something m of type M\u003cB\u003e is returned. Secondly, m is “unwrapped” to reveal something of type B and that something will be passed to f2. The result produced by f2 is the final result (of type M\u003cC\u003e, of course). Sure, the unwrapping can be failed. In this case, it’s up to magicCompose to determine something of type M\u003cC\u003e as the final result, and f2 could be ignored. The second step described above is actually over-specific, though it is the most common case. In general, at this step the magicCompose function can do whatever logic, use m and f2 in an arbitrary way, as long as it finally produces something of type M\u003cC\u003e. In fact, we need to make the magicCompose function be generic so that it can work with other functions, like f3, not only f1 and f2. Thus, the type of the magicCompose function should be generic: magicCompose: ('T -\u003e M\u003c'U\u003e) -\u003e ('U -\u003e M\u003c'V\u003e) -\u003e ('T -\u003e M\u003c'V\u003e) Use it: magicCompose f1 f2 Or we can use the operator \u003e=\u003e: f1 \u003e=\u003e f2 Remember \u003e=\u003e means magicCompose. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:2:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"The bind function Sometimes, we don’t want to do magicCompose on f1 and f2. For example, we may call f1 first, then receive something m of type M\u003cB\u003e; or all we have is just something m of type M\u003cB\u003e. Then we need a function which helps passing m to f2, and finally receive a result of type M\u003cC\u003e. This function actually does the second step of the magicCompose function as described above. We call it the bind function. The operator counterpart is \u003e\u003e=. The type of the bind function: bind: M\u003c'U\u003e -\u003e ('U -\u003e M\u003c'V\u003e) -\u003e M\u003c'V\u003e Use it: bind (f1 a) f2 bind m f2 Or using the operator \u003e\u003e=: f1 a \u003e\u003e= f2 m \u003e\u003e= f2 As we can see, the magicCompose function is merely built on-top of the bind function. Remember \u003e\u003e= means bind. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:3:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"The unit function How about the function f4? Its type is still D -\u003e E, it is out of the league of functions with type 'T -\u003e M\u003c'U\u003e. Hence f4 cannot be composed with any function of that league in a uniform way. So we need a way to convert f4 from type D -\u003e E to type D -\u003e M\u003cE\u003e. That way uses a unit function which transforms the output of f4 (type E) to something of type M\u003cE\u003e. So we can make f4 joining the league by writing: f4 \u003e\u003e unit Now, to compose f3 with f4, we write: f3 \u003e=\u003e (f4 \u003e\u003e unit) The unit function should be trivial / simple / stupid / straightforward / obvious. For example, if E is int and M\u003cE\u003e is int list, then unit e should return a list with only one element: e. Type of the unit function, generic, of course: unit: 'T -\u003e M\u003c'T\u003e Notice that unit is also a member of the league of functions with type 'T -\u003e M\u003c'U\u003e. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:4:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"The map function Sometimes, this code: m \u003e\u003e= (f4 \u003e\u003e unit) can be shortened as: m \u003c!\u003e f4 The \u003c!\u003e operator is called map operator. In its function form, we write: map m f4 We can see that the map function is merely built on-top of the bind and unit functions: map m f = m \u003e\u003e= (f \u003e\u003e unit) Type of the map function: map: M\u003c'T\u003e -\u003e ('T -\u003e 'U) -\u003e M\u003c'U\u003e Remember \u003c!\u003e means map. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:5:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"Monad definition Now we have the definition of a monad: What The type M\u003c'T\u003e, together with the two functions bind and unit, define a monad. and recognize its importance: Why Monads helps composing type incompatible functions. There is an interesting analogy: if the set of the 'T -\u003e M\u003c'U\u003e functions was a set of numbers, then the magicCompose operator would be an numeric operator like + - * /, and the unit function would be the neural number (like 0 for +, or 1 for *). This analogy leads to three laws of a monad. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:6:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"The three monad laws Strictly speaking, a true monad needs to obey the three laws below: Left identity: unit \u003e=\u003e f = f just like 0 + n = n or 1 * n = n. Right identity: f \u003e=\u003e unit = f just like n + 0 = n or n * 1 = n. Associativity: f \u003e=\u003e (g \u003e=\u003e h) = (f \u003e=\u003e g) \u003e=\u003e h just like x + (y + z) = (x + y) + z or x * (y * z) = (x * y) * z. It is not that just because of the analogy we have these three laws. They also have practical benefits. The practical benefit for the 3rd law is obvious: it would be very surprised for programmers when seeing f \u003e=\u003e (g \u003e=\u003e h) produces something different from (f \u003e=\u003e g) \u003e=\u003e h. Regarding the 2nd law, consider when we want to magicCompose a function f with the identity function. The identity function is a function which returns output same as input, and is often denoted as id. Since id has type of 'T -\u003e 'T, we need to use the unit function in order to make id composable with f, so we write: f \u003e=\u003e (id \u003e\u003e unit) In our subconscious, every function when composing with id will produce the same function. We want this rule to apply to magicCompose too. Therefore, we want to see: f \u003e=\u003e (id \u003e\u003e unit) = f Obviously, id \u003e\u003e unit = unit, so what we want to see is actually the 2nd law: f \u003e=\u003e unit = f. And the 1st law is just a consequence of the other laws. Keep in mind these three laws when designing the bind and unit functions of a monad. Make sure they are satisfied. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:7:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Programming"],"content":"Final thought Function composition is so important in functional programming that every functional language tries to make this comfortable as much as possible. In F#, to compose two functions with compatible types, we just use the built-in \u003e\u003e operator; to compose two functions with incompatible types, we write a monad and often name the involved operators as \u003e=\u003e for magicCompose, \u003e\u003e= for bind, and \u003c!\u003e for map. The core library of the language also provides some handy monads such as Option, Result, and Async. It even provides a killer feature called Computation Expressions for situations where the use of operators causes harm to code readability. To conclude, monads are just a design pattern – a very important pattern in functional programming – which aids function composition. ","date":"November 30, 2017","objectID":"/posts/2017/11-30-some-thoughts-on-monads/:8:0","tags":["FunctionalProgramming","Monad","DesignPattern"],"title":"Some thoughts on monads","uri":"/posts/2017/11-30-some-thoughts-on-monads/"},{"categories":["Math"],"content":"Một bài cực khó của kì thi Toán quốc tế (IMO) 2017 diễn ra tại Rio de Janeiro vào tháng 7 vừa qua. Theo quan sát của một thanh niên an nam thì chỉ có duy nhất một thanh niên nga ngố tên là Mikhail Ivanov giải trọn vẹn bài này trong phòng thi. Thanh niên an nam cũng cố giải, nhưng trong một phòng khác. ","date":"November 12, 2017","objectID":"/posts/2017/11-12-giai-bai-3-imo-2017/:0:0","tags":["IMO"],"title":"Giải bài 3 - IMO 2017","uri":"/posts/2017/11-12-giai-bai-3-imo-2017/"},{"categories":["Math"],"content":"Đề bài Một cô thợ săn và một con thỏ tàng hình chơi trò chơi sau trên mặt phẳng. Điểm xuất phát $A_0$ của con thỏ và điểm xuất phát $B_0$ của cô thợ săn trùng nhau. Sau $n-1$ lượt chơi, con thỏ ở điểm $A_{n-1}$ và cô thợ săn ở điểm $B_{n-1}$. Ở lượt chơi thứ $n$, có ba điều lần lượt xảy ra theo thứ tự dưới đây: Con thỏ di chuyển một cách không quan sát được tới điểm $A_n$ sao cho khoảng cách giữa $A_{n-1}$ và $A_n$ bằng đúng $1$. Một thiết bị định vị thông báo cho cô thợ săn về một điểm $P_n$, đảm bảo khoảng cách giữa $P_n$ và $A_n$ không lớn hơn $1$. Cô thợ săn di chuyển một cách quan sát được tới điểm $B_n$ sao cho khoảng cách giữa $B_{n-1}$ và $B_n$ bằng đúng $1$. Hỏi điều sau đây sai hay đúng: cho dù con thỏ có di chuyển như thế nào và các điểm được thiết bị định vị thông báo có là những điểm nào, cô thợ săn luôn có thể chọn cho mình cách di chuyển sao cho sau $10^9$ lượt chơi, cô ta có thể khẳng định chắc chắn rằng khoảng cách giữa mình và con thỏ không vượt quá $100$? ","date":"November 12, 2017","objectID":"/posts/2017/11-12-giai-bai-3-imo-2017/:1:0","tags":["IMO"],"title":"Giải bài 3 - IMO 2017","uri":"/posts/2017/11-12-giai-bai-3-imo-2017/"},{"categories":["Math"],"content":"Lời giải thử Câu trả lời là không! Cô thợ săn không thể nào chọn được một cách di chuyển như vậy. Để chứng minh, chúng ta giả sử rằng con thỏ nắm quyền điểu khiển máy định vị. Sau đó ta sẽ bày cho thỏ một cách “dụ” cô thợ săn sao cho khoảng cách giữa nó và cô thợ săn sẽ tăng dần, và đạt hơn $100$ sau $10^9$ lượt chơi. Tạm đặt $n$ là một số nguyên dương và $\\alpha$ là một góc sao cho $sin\\alpha = 1/n$. Thỏ sẽ chơi như sau. Trong $n$ lượt chơi đầu tiên, thỏ di chuyển đều theo một tia thẳng $u$ bất kì, cụ thể tại lượt thứ $i$ $(i=1..n)$ thì nó nhảy đến một vị trí cách điểm ban đầu một khoảng là $i$. Còn máy định vị thì bị thỏ điều khiển và báo các vị trí tạo thành một tia thẳng $t$ hợp với $u$ một góc bằng $\\alpha$, cụ thể tại lượt thứ $i$ thì máy báo một vị trí cách điểm ban đầu một khoảng là $i cos\\alpha$. Nói cách khác, như trong hình 1 dưới đây, nếu coi điểm ban đầu là gốc toạ độ $(0, 0)$ và $t$ là tia dương của trục hoành, thì tại lượt thứ $i$, thỏ sẽ nhảy tới toạ độ $( icos\\alpha, isin\\alpha )$, và máy sẽ báo toạ độ $( icos\\alpha, 0 )$. Dễ thấy khoảng cách giữa thỏ và vị trí mà máy định vị báo vẫn được đảm bảo không vượt quá $1$. Hình 1 Sau $n$ lượt chơi đầu tiên như thế, gọi khoảng cách giữa hai nhân vật là $d$, ta có thể giả sử $d \\leq 100$, vì nếu $d \u003e 100$ thì xong phim. Ngoài ra, $d$ có thể bằng $0$ (thỏ quá xui), nhưng không sao, lúc này thỏ đã ghi nhớ các bước đi của cô thợ săn trong $n$ lượt đầu tiên. Tiếp theo, thỏ lại điều khiển máy định vị báo các vị trí theo cách y hệt $n$ lượt trước. Nghĩa là, trong các lượt từ $n+1$ tới $2n$, máy lại báo các vị trí nhích dần sang phải trên trục hoành như trong hình 2. Cô thợ săn thấy máy định vị báo y như cũ, sẽ di chuyển vũ như cẩn. Do vậy, thỏ biết trước vị trí của cô thợ săn sau lượt $2n$, nó sẽ chọn cách di chuyển hoặc là theo tia $u$, hoặc là theo tia $v$ đối xứng với $u$ qua trục hoành (như hình 2) sao cho khoảng cách $d’$ giữa nó và cô thợ săn, sau lượt $2n$, là xa nhất có thể. Hình 2 Dễ thấy $d’$ nhỏ nhất là bằng đoạn $AB$ trong hình 2, trong đó $A$ và $B$ tương ứng là vị trí kết thúc của cô thợ săn và con thỏ sau lượt $2n$. Bây giờ chúng ta tính xem $d’$ lớn hơn $d$ được bao nhiêu. Chính xác hơn, là tính xem $d’^2$ lớn hơn $d^2$ được bao nhiêu. Ta có: $OC^2 = OB^2 - BC^2 = n^2-1$ suy ra $OC = \\sqrt{n^2-1}$ Thế và: $OA = DA - OD = n - d$ Do đó: $AC = OC - OA = \\sqrt{n^2-1} - n + d$ Biết $AC$ rồi thì tính được $AB^2$: $AB^2 = AC^2 + CB^2 = (\\sqrt{n^2-1} - n + d)^2 + 1$ Tức là: $d’^2 = (d - (n-\\sqrt{n^2-1}))^2 + 1$ Đặt: $n-\\sqrt{n^2-1} = e$ ta có: $d’^2 = (d - e)^2 + 1 = d^2 - 2de + e^2 + 1$ Vậy là $d’^2$ lớn hơn $d^2$ một khoảng bằng $e^2 - 2de + 1$ Do $d \\leq 100$, nên: $e^2 - 2de + 1 \\geq$ $e^2 - 200e + 1 =$ $(n-\\sqrt{n^2-1})^2 - 200(n-\\sqrt{n^2-1}) + 1 =$ $2n^2 - 1 - 2n \\sqrt{n^2-1} - 200n + 200 \\sqrt{n^2-1} + 1 =$ $2n (n-\\sqrt{n^2-1}) - 200(n-\\sqrt{n^2-1}) =$ $2(n-100) (n-\\sqrt{n^2-1})$ (*) Theo hằng đẳng thức đáng nhớ $(a-b)(a+b)=a^2-b^2$, ta có: $(n-\\sqrt{n^2-1}) (n+\\sqrt{n^2-1}) = n^2 - (n^2-1) = 1$ Suy ra: $n-\\sqrt{n^2-1} = 1 / (n+\\sqrt{n^2-1}) \u003e 1 / (n+\\sqrt{n^2}) = 1/(2n)$ Vậy (*) trở thành: $e^2 - 2de + 1 \u003e 2(n-100) \\cdot 1/(2n) = (n-100)/n$ Tóm lại: $d’^2 - d^2 \u003e (n-100)/n$ Lấy $n=10000$ ta có cứ sau mỗi $10000$ lượt chơi (kể từ lượt thứ $10001$ trở đi) thì bình phương của khoảng cách giữa 2 nhân vật lại tăng thêm ít nhất là hơn $(10000-100)/10000 = 0.99$ Như vậy, sau cả thảy $10^9$ lượt chơi, bình phương khoảng cách giữa con thỏ và cô thợ săn sẽ ít nhất là lớn hơn: $(10^9 - 10000) / 10000 \\cdot 0.99 =(10^5-1) \\cdot 0.99 = 99999 \\cdot 0.99 \u003e 99999 \\cdot 0.5 \u003e 44444 \u003e 10000$ Bình phương khoảng cách lớn hơn $10000$, tức là khoảng cách lớn hơn $100$. Thỏ đã thắng! ","date":"November 12, 2017","objectID":"/posts/2017/11-12-giai-bai-3-imo-2017/:2:0","tags":["IMO"],"title":"Giải bài 3 - IMO 2017","uri":"/posts/2017/11-12-giai-bai-3-imo-2017/"},{"categories":["Math"],"content":"Gradient Boosting is a machine learning technique which boosts weak learners to strong ones by using gradient. My explanation here: https://www.slideshare.net/katatunix/gradient-boosting ","date":"December 08, 2016","objectID":"/posts/2016/12-08-gradient-boosting/:0:0","tags":["GradientBoosting","MachineLearning"],"title":"Gradient Boosting","uri":"/posts/2016/12-08-gradient-boosting/"},{"categories":["Math"],"content":"My simple explanation of the Hidden Markov Model. Shared here: https://www.slideshare.net/katatunix/hidden-markov-model-67982915 ","date":"November 11, 2016","objectID":"/posts/2016/11-11-hidden-markov-model/:0:0","tags":["HiddenMarkovModel","MachineLearning"],"title":"Hidden Markov Model","uri":"/posts/2016/11-11-hidden-markov-model/"},{"categories":["Math"],"content":"The relationship between universe and projective geometry","date":"August 11, 2016","objectID":"/posts/2016/08-11-the-universe-is-4d/","tags":["Universe","ProjectiveGeometry","4DSpace"],"title":"The universe is 4D?","uri":"/posts/2016/08-11-the-universe-is-4d/"},{"categories":["Math"],"content":"This statement: Quote Little did they know that the universe is four dimensional and even the orbit of planets is an illusion produced when straight motion in a four dimensional space is projected into three dimensions (or something). immediately reminded me about projective geometry which is one of the most beautiful systems of mathematics. So the universe is 4D? I’m not sure. But if it was true then we could use the concepts of projective geometry to interpret something interesting. So the universe is 4D! But how can we imagine a 4D space? It’s nearly impossible to get a perception of 4D without going out of the current 3D space. What would we meet when we went out of the 3D space? Intuitively, the answer is points at infinity, lines at infinity and a plane at infinity. This begs a question: what are the coordinates of these infinite stuff? Of course using 3 components like $(x, y, z)$ is insufficient. That’s why we need 4 components $(x, y, z, w)$ to represent all points/lines/planes including finite and infinite ones. Hence the name 4D. Projective geometry uses homogeneous coordinate system in which $(x, y, z, 0)$ represents a point at infinity following $(x, y, z)$ direction, and $(x, y, z, w)$ with $w \\ne 0$ represents a normal point with usual coordinate $(x/w, y/w, z/w)$. The funny part is when you travel to a point at infinity and meet a stranger there. If you ask him about the coordinates of the current point you may get a very different answer: the point is not at infinity in his eyes! What does this mean? The 3D world we are living in and perceiving is just one particular 3D space projected from a 4D space – the universe. Infinite points of this world are finite ones of other worlds. The only way to move from a world to other worlds is traveling to infinity of that world. The number of worlds may be infinite too. Ironically… Points at infinity do not exist. It is just a notion to refer to a certain subset of points in 4D space that cannot be projected into a certain 3D space and therefore are missed and non-existed in that 3D space. In 4D space every point is treated equally, nothing is called infinity. ","date":"August 11, 2016","objectID":"/posts/2016/08-11-the-universe-is-4d/:0:0","tags":["Universe","ProjectiveGeometry","4DSpace"],"title":"The universe is 4D?","uri":"/posts/2016/08-11-the-universe-is-4d/"},{"categories":["Programming"],"content":"Null is evil","date":"August 03, 2016","objectID":"/posts/2016/08-03-null-references-the-billion-dollar-mistake/","tags":["Null","Exception"],"title":"Null References: The Billion Dollar Mistake","uri":"/posts/2016/08-03-null-references-the-billion-dollar-mistake/"},{"categories":["Programming"],"content":"Null is clearly evil. We as human tend to forget to check null, and boom… crash!!! Documentation may help, but again we still forget reading documents. Worse, not all documents are correct and up-to-date 100%. Even if we remember to do every null check, our code would be very messy. So what is the solution? Checked-exceptions can help but must be used with care otherwise nearly every function/method in our programs could throw checked-exceptions, and try/catch statements would appear everywhere. Unchecked-exceptions basically don’t solve the problem of null. But at least they are a bit better than null because they can carry descriptive messages and make programs crash exactly at exact locations (with null the crashes only happen when null is accessed afterward). NullObject pattern can avoid crashing when we forget checking the returned object, but then we might forget it forever since no error is thrown at both compile-time and run-time. Moreover, in order to use NullObject pattern we have to change a class to an interface, sometimes such a change is not desired. Recently, Optional has been emerged as a good alternative for null. In my opinion, this alternative still has the problem of checked-exceptions. If we aren’t careful, Optional could be everywhere in our code. A disadvantage of Optional is, to achieve clean code we have to learn Maybe monad, map, reduce, filter – these are very important concepts of Functional Programming. But when we grasp the concepts, it’s really great! Tony Hoare is the author of the quote in the featured image. ","date":"August 03, 2016","objectID":"/posts/2016/08-03-null-references-the-billion-dollar-mistake/:0:0","tags":["Null","Exception"],"title":"Null References: The Billion Dollar Mistake","uri":"/posts/2016/08-03-null-references-the-billion-dollar-mistake/"},{"categories":["Programming"],"content":"Exceptions are a very common concept in most of languages nowadays. In this article we will discuss why exceptions are needed, checked vs. unchecked exceptions, and why C# doesn’t have checked exceptions. ","date":"July 16, 2016","objectID":"/posts/2016/07-16-how-do-you-use-exceptions/:0:0","tags":["Exception","Java","CSharp"],"title":"How do you use Exceptions?","uri":"/posts/2016/07-16-how-do-you-use-exceptions/"},{"categories":["Programming"],"content":"In the old days, defensive code were a mess Before exceptions were invented, defensive code had been overwhelmed with a lot of error checking and recovery from those errors, for example: void handle() { // style #1: error is embedded in the return value int errFoo = foo(); if (errFoo == -1) { // recovery and may return } // style #2: error is assigned to the output parameter unsigned int errBar; int value = bar(..., \u0026errBar); if (errBar != 0) { // recovery and may return } // do something with value // style #3: a separated \u0026 global function to get error kaka(); int errKaka = getKakaError(); if (errKata == 1) { // recovery and may return } // the rest } The style #1 is most intuitive but it requires the return value to have a slot for storing the error. If that slot is not available, we can use the style #2 however this style may create a long list of parameters which is often annoying. The style #3 is quite common in OpenGL, OpenAL, EGL with a disadvantage is that we are very likely to forget the error checking. No matter which style is chosen, the code is really messy because happy code and defensive code are mixed together. ","date":"July 16, 2016","objectID":"/posts/2016/07-16-how-do-you-use-exceptions/:1:0","tags":["Exception","Java","CSharp"],"title":"How do you use Exceptions?","uri":"/posts/2016/07-16-how-do-you-use-exceptions/"},{"categories":["Programming"],"content":"With exceptions, happy code and defensive code are separated In a language that supports exceptions – such as Java – the code above could be rewritten as: public void handle() { try { foo(); int value = bar(); // do something with value kaka(); } catch (Exception e) { // recovery and may return } // the rest } Isn’t it much cleaner? In case the try block is too long, no worries, you can always extract it to another method: public void handle() { try { handleWithException(); } catch (Exception e) { // recovery and may return } // the rest } private void handleWithException() throws Exception { foo(); int value = bar(); // do something with value kaka(); } Another common case is, the handle method would delegate the recovery job to its callers, by indicating it also throws an exception just like foo, bar and kaka. Now the code cannot be cleaner: public void handle() throws Exception { foo(); int value = bar(); // do something with value kaka(); // the rest } You may notice that the exceptions I described above are called checked exceptions. ","date":"July 16, 2016","objectID":"/posts/2016/07-16-how-do-you-use-exceptions/:2:0","tags":["Exception","Java","CSharp"],"title":"How do you use Exceptions?","uri":"/posts/2016/07-16-how-do-you-use-exceptions/"},{"categories":["Programming"],"content":"Checked exceptions: you are forced to check As you see, a checked exception is a part of the method signature: public void handle() throws Exception therefore compiler would complaint if the callers of the handle method didn’t check the exception explicitly by either surrounding the call inside a try/catch block or re-throwing the exception. By this way, those callers would never forget checking the exception. It’s good, right? It’s not always good. There are cases in which the callers don’t want to be annoyed by the exception. They don’t care whether the exception happens or not, or they are sure that the exception will never happen. If it does, just let it be implicitly bubbled up to the caller. Eventually no caller catches that exception? No problem! The program should crash immediately because e.g. it is a bug and needs to be fixed, not to be hidden. The style of such a program is named as fail-fast. And exceptions fulfilling that situation are called unchecked exceptions. ","date":"July 16, 2016","objectID":"/posts/2016/07-16-how-do-you-use-exceptions/:3:0","tags":["Exception","Java","CSharp"],"title":"How do you use Exceptions?","uri":"/posts/2016/07-16-how-do-you-use-exceptions/"},{"categories":["Programming"],"content":"Unchecked exceptions: you are not forced to check Unchecked exceptions are flexible since the checking is not mandatory. In Java, java.lang.RuntimeException is the base unchecked exception; some of common derived unchecked exceptions are NoSuchElementException and NumberFormatException. The former one is associated with the next method of an Iterator, but because we usually check the hasNext method before calling next so it would be very annoying if the next threw a checked exception. The NumberFormatException is thrown when e.g. we convert an invalid string to a number. This is often a result of a mistake from developers, hence that NumberFormatException is an unchecked exception is reasonable. ","date":"July 16, 2016","objectID":"/posts/2016/07-16-how-do-you-use-exceptions/:4:0","tags":["Exception","Java","CSharp"],"title":"How do you use Exceptions?","uri":"/posts/2016/07-16-how-do-you-use-exceptions/"},{"categories":["Programming"],"content":"Principle: “Don’t use exceptions for flow control” You can have a read on the discussion of this principle here. Basically, since exceptions – just like return values – are also a way to indicate the result of a method, so you can cheat by throwing an exception for a normal result. Yes, it works! But it’s dirty and does cause confusing to its callers. That’s why the principle. Now let’s take the principle to an extreme level. Technically speaking, whenever you catch an exception, it is flow control. In the catch block, even if you just print logs, or even do nothing, it is still flow control. Thus, in my opinion, the principle should be rewritten as: “Don’t use exceptions for returning normal results”. ","date":"July 16, 2016","objectID":"/posts/2016/07-16-how-do-you-use-exceptions/:5:0","tags":["Exception","Java","CSharp"],"title":"How do you use Exceptions?","uri":"/posts/2016/07-16-how-do-you-use-exceptions/"},{"categories":["Programming"],"content":"Why C# doesn’t have checked exceptions? To me this was a good decision of the language created by Microsoft. Checked exceptions have a profound problem that we might have to practice a lot to recognize it. Back to the handle method above, in reality, it’s very likely that the method would delegate the recovery job to the callers because e.g. it has no enough information or simply no responsibility to do the job. So its signature changes. Immediately, all of its current callers are affected. This affection is really strong since the source code of callers must change also. Worse, those changes may be propagated to the callers of callers and so on. Of course, without checked exceptions, the risk is that we may forget checking an exception that should have been checked. But I don’t think this is a big problem, that exception should happen very soon if our system is well tested, so we can fix it easily. Moreover, if methods are well documented, we can detect an exception early even though it is not reminded by compiler. ","date":"July 16, 2016","objectID":"/posts/2016/07-16-how-do-you-use-exceptions/:6:0","tags":["Exception","Java","CSharp"],"title":"How do you use Exceptions?","uri":"/posts/2016/07-16-how-do-you-use-exceptions/"},{"categories":["Programming"],"content":"This article is about my personal explanation of the famous design patterns: Model View Controller (MVC), Model View Presenter (MVP), Presentation Model (PM), and Model View ViewModel (MVVM). Let’s start with Model. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:0:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"Model: the core of an application At the core of an application is a component called Model where business objects and use-case objects live. Normally, the outside world interacts with the Model by sending input to the use-case objects, these objects then manipulate the business ones and finally return output back to the outside world. That outside world implies a new component, we name it UI – User Interface – or View. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:1:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"User Interface: the born of View When we think about a View, we usually consider that it’s purely about visualization. However, the fact is that we tend to put some more logics into a View. They are: Interaction logic: this logic defines how the controls (such as text boxes, combo boxes, buttons…) inside a View behave according to some certain rules. For example, if the text box A is empty then the button B is disabled, if the button B is clicked then the content of the text box A is chosen as input to be sent to the Model, and so on. The logic of input converting: the format of the input entered by users into the View might be different to the format of the input accepted by the Model. For example, consider a Model that requires an integer number as input, but what the View has is a string entered by users, in this case the View has to do the converting from string to integer. The logic of output converting: similarly, there are mismatches between the format of the output returned by the Model and the format that the View will use to visualize those output. In a simple application, those three logics of a View are pretty trivial, thus directly putting them into the View is fine. But in a large application with a lot of Views and Models, chance is that we should separate some of the logics into a new component. We call this new component man-in-the-middle. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:2:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"Benefits of the separation Putting some or all of the View logics into the man-in-the-middle component offers some benefits. Firstly, the View would be more cohesive and thus can be reused in various contexts. For instance, a View would be able to work with many different Models if it doesn’t have any knowledge about the input/output format of any Model. Secondly, the View logics, of course, would be reusable and therefore testable. If those logics are embedded in the View, unit testing for them would be very difficult. Depending on one, or two, or three of the View logics are assigned to the man-in-the-middle component, we will have either MVC, or MVP, or PM pattern. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:3:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"MVC: Controller is an input converter MVC: Controller is an input converter As depicted in the figure above, in this pattern, only the logic of input converting is assigned to the man-in-the-middle component – named as Controller. The Controller, after converting the input sent from the View, will send the formatted version to the Model. But then, how are output returned from the Model? Because the Controller doesn’t do the output converting, it’s better to let this component be unaware of the output. So, the Model should not return the output as Return Values (i.e. using the return keyword) to the Controller. Instead, the Model will send the output to the View, through an interface – this interface is called Use Case Output Port – so the Model will not know about the View (the Model definitely must not know about anything outside it). Of course, when the View receives the output, it has to do the output converting by itself. Notice that, the initial View and the final View are not necessarily the same. They might be two different Views, as illustrated in the figure below: MVC with two different Views This case is rare but it’s worth to be aware. Actually, in the classic definition of MVC, the initial View is not mentioned, only the final one is. Nevertheless, I find that mention of the initial View would make easier to understand the pattern. Input converting note There is a detail of input converting: sometimes the converting fails due to invalid input, thus an input validation is implied when converting. If a failure happens, the Controller will – without any intervention of the Model – directly notify output (e.g. an error message) to the View. But this validation should cover the converting only. I’ve seen people involving business logics – which inherently belong to the Model – when validating input in the Controller. This would scatter business logics across the Model and the Controller, and therefore, in my opinion, should be restricted. MVC pattern still leaves the logic of output converting in the View. If we don’t like this, we could adopt the MVP pattern. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:4:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"MVP: Presenter is a Controller plus an output converter MVP: Presenter is a Controller plus an output converter As the figure above depicts, both of the two converting logics are now assigned to the man-in-the-middle component. In this manner, the component looks like someone who presents already formatted data to the View, so it could be named as Presenter. It is not really clear that MVP facilitates unit testing better than MVC does: On one hand, the testing of the output converting in MVP is possible because that logic is not embedded in the View anymore. Moreover, MVC forces that every Model must return output through Output Ports, this always requires mocking when writing unit tests for the Model. In MVP, the output of Model can be Return Values, thus mocking is not mandatory. On the other hand, since the Presenter has more than one responsibility, writing unit testing for it would be more difficult. As we can see, a Presenter includes the logic of input converting plus the logic of output converting. Do we feel it is bulky? If the answer is yes, we may want to consider the MVCP pattern. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:5:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"MVCP: why not both Controller and Presenter? Nothing special to this pattern except that it extracts a Controller from a bulky Presenter. The Presenter is really a pure Presenter as it doesn’t do the logic of a Controller anymore. MVCP pattern is not mine (but the name might be), it was introduced by Uncle Bob in his workshop Architecture – The Lost Years: Uncle Bob in his workshop Architecture - The Lost Years In the diagram, the Interactor is actually the Model (or use-case object), the upper Boundary interface is the Use Case Input Port, the lower one is the Use Case Output Port. See the workshop or read this article of Uncle Bob for more information. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:6:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"PM: Presenter holds all the “model” states of the View in order to perform all View logics Observant readers would guess that PM pattern – credit to Martin Fowler – is an extreme pattern where all the View logics – converting and interaction – are performed by the man-in-the-middle component – which is still called Presenter. But unlike converting logics, interaction logic requires the Presenter to hold all the model states of the View. What are the model states of a View? Even a simple View contains a lot of states: text colors, font sizes, font styles… such kind of states is merely for visualization and is not concerned by the View logics. But states like the content of the text box A, the status checked/unchecked of the check box B… are very important and indeed must be accessed and manipulated by the View logics. These states are called model states. Obviously, the model states of a View belong to that View and thus are held by that View. So, by saying “Presenter holds all the model states of the View” we mean that the Presenter holds a copy of all the model states of the View. This requires a synchronization mechanism: every change of the model states in the View must be notified to the Presenter, and vice-versa. We can see this in the figure below: PM: Presenter holds all the model states of the View in order to perform all View logics Now the View does not need to decide – as before – which model states that will be chosen and sent as input to the Presenter. Such logic – and every logic – is handled by the Presenter. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:7:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"MVVM: PM with a mark-up View and a data binding framework The View in the PM pattern is really pure, since it doesn’t contain any logic. This turns out to be a good chance to implement the View in a language that does not fully support logics and hence is more friendly to non-programmer people like UI/UX designers. A good example of such a language is a mark-up one like XML. But implementing the View in a different language to the Presenter also means that the synchronization of the model states between the two components is nearly impossible without a framework (or platform/library) that understands both of the two components. Such a framework is called data binding where the data synchronization is performed in an implicit manner. The job of developers is just configuring which properties of this component will be synced to which properties of that component. So, yes, MVVM pattern is essentially PM pattern with a mark-up or GUI-code View and a data binding framework. Notice that, those things are implementation details, thus, from the architectural view, there is no really difference between PM and MVVM. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:8:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"Judgement: MVC vs. MVP vs. MVCP vs. PM vs. MVVM Deciding whether to use which pattern is quite a hard trade-off. It depends on how we distribute and balance tasks to our components. If a Controller is fat, it should not become a Presenter in MVP. If a View is complex, it should not take the logic of output converting as in MVC. If a Presenter is big, it should be separated as in MVCP. If a View is really needed to be pure, PM is the good choice. However, after all, the evaluation of fat/complex/big/pure is really an art and subtle. Because of this difficulty, sometimes our decision is mainly driven by our habit. To adopt MVVM, obviously, our framework must support (1) a mark-up language or GUI-code for View development, and (2) a data binding mechanism. In many cases, such a framework is so attractive that it dominates all of the other patterns. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:9:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"Conclusion All the design patterns discussed in this article are usually applied in large software which involve the participation of UI. Although these patterns differ slightly – MVC moves the logic of input converting from the View to the Controller, MVP moves both of the input and output converting to the Presenter, PM promotes the Presenter to handle the interaction logic also, and MVVM is basically PM with some useful features of some framework – all of them are for only one purpose: separation of concerns. The Controller/Presenter/ViewModel only concerns the logics of the View, the Model only handles the logics of business, and the View only concerns about visualization. Separation of concerns, in my opinion, is the most valuable principle of software design. ","date":"March 17, 2016","objectID":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/:10:0","tags":["OOP","DesignPattern","MVC","MVP","PM","MVVM"],"title":"How to think about MVC, MVP, PM, and MVVM?","uri":"/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/"},{"categories":["Programming"],"content":"My personal explanation for Gang of Four's Builder Pattern","date":"March 14, 2016","objectID":"/posts/2016/03-14-gof-builder-pattern/","tags":["GangOfFour","DesignPattern","BuilderPattern"],"title":"GoF Builder Pattern","uri":"/posts/2016/03-14-gof-builder-pattern/"},{"categories":["Programming"],"content":"Builder Pattern and Factory Pattern are pretty similar in a way: both of them encapsulate the details of object-creation processes. However, in cases there are many complicated processes to create various representations of objects, and those processes share a common trait, Builder Pattern is the better choice. Let’s say we have two processes to build a house: Asian process and European one. We will start with Factory Pattern and gradually adapt it to Builder Pattern. A possible implementation of Factory Pattern could be: class HouseFactory { public House createAsianHouse() { House h = new House(); // build basement h.set...(); ... // build roof h.set...(); ... // build interior h.set...(); ... return h; } public House createEuropeanHouse() { House h = new House(); // build basement h.set...(); ... // build roof h.set...(); ... // build interior h.set...(); ... return h; } } void main() { HouseFactory fac = new HouseFactory(); House asianHouse = fac.createAsianHouse(); House europeanHouse = fac.createEuropeanHouse(); } The two processes might be very complicated but they always have the same manner: build basement, then build roof, and then build interior. Thus, there is a subtle duplication in the code above. Clearly, it’s hard to maintain the code with duplication. For example, removing the build interior step from every process will require modifying code in two places. The same annoyance for adding back the step into every process. Of course, we love DRY (Don’t Repeat Yourself) principle! We want to eliminate the duplication! How? Let’s discard the code above and come up with a more general method, like this: class X { public House buildHouse() { buildBasement(); buildRoof(); buildInterior(); return getResult(); } } It looks good. But the method must provide an option for building either an Asian house or an European house. So we will add a parameter called option to the method: class X { public House buildHouse(option) { // what should we do with option and // the four calls below? buildBasement(); buildRoof(); buildInterior(); return getResult(); } } The two questions in the code above must be answered in order to give the method an ability of calling alternative versions of the four calls, depending on whether the passed option is about Asian or European. Here is the answer: class X { public House buildHouse(Y option) { option.buildBasement(); option.buildRoof(); option.buildInterior(); return option.getResult(); } } So, the boy option is an object that directly builds a house, he can be either an Asian builder or an European builder. From the viewpoint of the girl X, she doesn’t care where the builder comes from, she just needs to know he is a builder and she can ask him to work. Hence, the type Y should be an interface named Builder, and the type X could be named as Director: interface Builder { void buildBasement(); void buildRoof(); void buildInterior(); House getResult(); } class Director { public House buildHouse(Builder builder) { builder.buildBasement(); builder.buildRoof(); builder.buildInterior(); return builder.getResult(); } } Now we implement the concrete jobs of Asian and European builders: class AsianBuilder implements Builder { private House h; public AsianBuilder() { h = new House(); } public void buildBasement() { h.set...(); ... } public void buildRoof() { h.set...(); ... } public void buildInterior() { h.set...(); ... } public House getResult() { return h; } } class EuropeanBuilder implements Builder {...} And finally take them together into the main method: void main() { Director dir = new Director(); House asianHouse = dir.buildHouse(new AsianBuilder()); House europeanHouse = dir.buildHouse(new EuropeanBuilder()); } ","date":"March 14, 2016","objectID":"/posts/2016/03-14-gof-builder-pattern/:0:0","tags":["GangOfFour","DesignPattern","BuilderPattern"],"title":"GoF Builder Pattern","uri":"/posts/2016/03-14-gof-builder-pattern/"},{"categories":["Programming"],"content":"My personal explanation and justification for ECS","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"In recent years, Entity-Component System (ECS) has been recognized as the most notable architecture for game development. There are many good articles about the architecture that can be found on the Internet, some of them are: Entity Systems are the future of MMOG development What is an entity system framework for game development? Why use an entity system framework for game development? Understanding Component-Entity-Systems gamedev.stackexchange.com Entity Systems Wiki Entity component system Of course these articles are excellent and well-written, but one thing I don’t like about them is that they are not fair at comparing OOP and ECS. They think that class inheritance is fundamental to OOP thus they blame OOP in order to praise ECS as a preference of composition over inheritance. I’m not going to say that ECS is not deserved for that praising. Indeed, the articles pointed many undoubted benefits of the trendy architecture. What I want to express is that OOP vs. ECS is not about Inheritance vs. Composition; rather, it is about Object-Oriented Paradigm vs. Clever Procedural Paradigm. The rest of this article is my personal explanation and justification for ECS. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:0:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Situation We start with a situation: Decomposing a game world which contains multiple game entities into parts. Each part can be either a data structure, or a function, or an object. Immediately, because we are object thinkers, we would consider each game entity as an object containing both data and functions. However now we are facing some problems. In the following section, we will discuss these problems and propose solutions in order to reach the ECS architecture. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:1:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Problem 1 An entity might have many aspects, and aspects can be reused for various kinds of entities. Examples of aspects include Position, Renderable, Movable… Each aspect may concern in certain data of the entity. As you can see there are cases in which the same data are concerned by multiple aspects, but this is the story of the problem 3. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:2:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Solution Inheritance: bad, of course, because of its inflexibility. Composition: good, an entity is a composition of its aspects so-called components. With composition, we can easily create a new entity class that has whatever aspects we want, for example: class Mario { public Mario(Position p, Renderable r, Movable m) {...} // Mario may have behaviors that merely // delegate to p/r/m: public void render() { r.render(); } public void move() { m.move(); } // or may have its own specific behaviors that // will never be reused for other entity classes public void fire() {...} } Position p = new Position(100, 200); Renderable r = new Renderable(p); Movable m = new Movable(p); Mario mario = new Mario(p, r, m); ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:2:1","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Problem 2 The aspects of an entity might change at run-time. Currently, for each entity kind, we have a concrete class for it (e.g. the Mario class above). So its aspects (e.g., Position, Renderable, Movable) are fixed at run-time. We cannot hide a Mario by removing the Renderable aspect from it when the game is running. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:3:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Solution Only one class for every entity kind: Entity class. Entity should not know about the concrete classes of its components. Rather, Entity simply holds references to all of its components in which each component is declared as belonging to an abstract type: Component class. This extreme design requires every entity doesn’t have its specific behaviors anymore (e.g., the fire behavior of Mario). All the behaviors must be extracted to components. An entity is merely a bag of components, nothing more. To be honest, the two problems above are not caused by OOP. Indeed, our proposed solutions so far haven’t broken any principle of OOP. However, consider the following important problems. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:3:1","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Problem 3 Components tend to heavily access data of one another. Clearly, many components could not stand alone. For instance, in the code above, the Renderable and Movable components need to access and modify the data of the Position component in order to render and move the entity correctly. The heavily accessing of data between objects is actually a very bad practice in OOP. Unfortunately, it is nearly un-avoided in game development. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:4:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Problem 4 There are global behaviors. Very often, in game development, we have behaviors that cannot belong to any entity. Collision detection is a clear example. To detect collisions, someone global needs to access Position of all entities. And that someone then notifies collision info to collided entities so that those entities could respond. Both the last two problems have one root cause: we are respecting encapsulation too much. Quote In programming languages, encapsulation is used to refer to one of two related but distinct notions, and sometimes to the combination thereof: A language mechanism for restricting access to some of the object’s components. A language construct that facilitates the bundling of data with the methods (or other functions) operating on that data. –Wikipedia In problem 3, because each component has it own behaviors bundled with its internal data, when these behaviors involve external data, they must talk with other components through getters and setters. In problem 4, no way to get rid of it, except that we break encapsulation. Global behaviors always require components to expose their internal data via getters and setters. This means that accessing to objects’ internal data is not restricted. As a result, components are not objects – in their true definition – anymore. So, if we accept breaking encapsulation with a lot of getters and setters, why do we still let components have it own behaviors bundled with its internal data? We should continue to break encapsulation by totally separating functions from data. All functions now are global and centralized in one place. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:5:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Solution Separate functions from data. Components contain data only. A function has a global access over components. It might interest on certain component classes and manipulate instances of those classes. Functions now are called systems or processors. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:5:1","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Procedural is bad? We have achieved ECS architecture. But you may say: This is Procedural Paradigm (PP)! It’s bad! Yes, but which are bad things about PP? Well, PP tends to create more dependencies between parts because PP has two kinds of dependencies: functions depend on data, and functions depend on functions. Remember, OOP, with encapsulation, has only one kind – the last one. Don’t worry! In ECS, systems don’t depend systems. Hmm, but, PP is terrible because in reality data structures are usually changed, and this leads to changes of all dependent functions. Don’t worry! In an ECS architecture, because of the clear organization, when a component structure is changed, we know that it will lead to changes in the systems only, and it is not too difficult to find out and fix those changes in the related systems. One could argue that in game development, data structures are more stable than functions. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:6:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Final note That’s why I call ECS architecture Clever Procedural Paradigm. In fact, when data and functions are separated, and data is more stable than functions, we can name the architecture as Data Oriented, or even Relational Data Oriented in some particular implementation. ","date":"January 26, 2016","objectID":"/posts/2016/01-26-oop-vs-ecs/:7:0","tags":["OOP","ProceduralProgramming","ECS","GameDevelopment"],"title":"OOP vs. ECS","uri":"/posts/2016/01-26-oop-vs-ecs/"},{"categories":["Programming"],"content":"Wikipedia defines imperative and declarative programming as: imperative programming is a style that uses statements that change a program’s state… focuses on describing HOW a program operates. declarative programming is a style that expresses the logic of a computation without describing its control flow… focuses on describing WHAT the program should accomplish in terms of the problem domain. When we read the definition of something, we tend to focus on terms that are already familiar to us, and then use those terms as a metaphor in order to understand the definition. Here in this case, we should think that, for short, imperative programming is about HOW whereas declarative one is about WHAT. Of course, those definitions are correct, but somehow confused and thus difficult to understand. How can we write a program without describing HOW? Finally, the computer must do the job and it must know exactly HOW to do. It turns out that the WHAT here is still a little of HOW, but in a different way. So every time I hear someone saying “imperative is HOW and declarative is WHAT”, I feel disappoint. Rather, I like to hear: “imperative code describes control flow whereas declarative code does not”. But what is control flow? Again, Wikipedia defines control flow correctly and clearly: control flow is the order in which INDIVIDUAL statements, instructions or function calls are executed The word INDIVIDUAL is important. Let’s look into a typical control flow code: doThis; doThat; if (thisIsTrue) doThis; else doThat; while (thisIsTrue) { doThis; doThat; } The code contains multiple INDIVIDUAL steps – statements, instructions, function calls – which are DISCRETE and separated by the semicolons. Because these steps are DISCRETE, each of them must change program’s state in order to contribute to the whole program; otherwise, that step is meaningless. And using assignments is the most popular way to change program’s state. The doThis, doThat in the code above can be one of following statements: int x = 0; x = 1; x++; x += 2; x = x + 3; x = foo(); bar(); As you can see, every statement without assignments (or their variants) is meaningless. Event the call to the void function bar() still changes program’s state since there must be at least one assignment inside bar(). Yes, this is imperative programming where assignments and semicolons are dominant. Declarative programming, on the other hands, does not have assignments, and hence does not need semicolons to separate steps, since there is no any step, no state change, no side-effect. In declarative world, everything is declared by its definition. To achieve a task, we have to specify and define its outcome (yeah, it is WHAT). For example, to check whether an integer number is prime, we need a definition and sub-definitions if needed: A prime number N is an integer number that is greater than 1, and does not have any divisor from 2 to N-1. A number N that does not have any divisor from 2 to N-1 is… well, we need recursion. Let’s see the code :) Translating to code: isPrime(N) = N \u003e 1 AND noDivisor(2, N) noDivisor(from, N) = from \u003e= N OR ( N % from \u003e 0 AND noDivisor(from + 1, N) ) Writing declarative code requires a very different thinking. The most challenge of converting imperative code into declarative one is eliminating loops because only loops really need state change. Indeed, without state change, the break conditions of loops will never be met, and loops that aggregate something are not possible. In many cases, if a loop is about going through a list to collect something, most declarative languages provide some built-in features such as map, reduce, filter, find with lambda expressions that are quite useful and succinct, since the HOW – how to go through the list – is left up to the language’s implementation. But in general cases, the only way to remove loops, of course, is recursion. Unfortunately, not every language is optimized for recursion. I could not say, imperative vs. declarative, whi","date":"November 11, 2015","objectID":"/posts/2015/11-11-imperative-vs-declarative/:0:0","tags":["Imperative","Declarative"],"title":"Imperative vs. Declarative","uri":"/posts/2015/11-11-imperative-vs-declarative/"},{"categories":["Math"],"content":"Hình học xạ ảnh (projective geometry) ám ảnh tôi trong suốt một thời gian dài. Đó là vào khoảng cuối năm 2011, khi mà OpenGL ES 2.0 trở nên thịnh hành trên những game cho thiết bị di động. Hệ điều hành iOS của Apple bắt đầu hỗ trợ OpenGL ES 2.0 từ iOS 5.0, còn phía Android là bắt đầu từ Android 2.2 (Froyo). Vì tính chất công việc, tôi bắt buộc phải cập nhật kiến thức để theo kịp công nghệ. Điểm đặc biệt và quan trọng nhất ở OpenGL ES 2.0 chắc chắn là shader. Đây thực sự là một cuộc cách mạng của ngành đồ họa máy tính. Vì shader có thể lập trình được (programable), nó cung cấp cho chúng ta một cơ chế vô cùng linh hoạt và mạnh mẽ để quyết định màu của pixel (fragment) sẽ được vẽ ra màn hình. Đây là điều mà ở OpenGL ES 1.1 với fixed function không hề có. Và rất nhiều hiệu ứng đồ họa chỉ có thể làm được với shader mà thôi. Tôi chú ý đến vertex shader, đoạn cuối của nó rất hay như này: gl_Position = a_position * u_projectionMatrix; Các position dĩ nhiên đều là tọa độ 3D, nhưng tại sao kiểu của chúng ở đây lại là vector 4D với 4 thành phần (x, y, z, w)? Thế và, vì chúng là vector 4D, nên ma trận projection cũng là ma trận 4x4 chứ không phải 3x3. Một lời giải thích dễ dãi thường như sau: với mỗi tọa độ (x, y, z) của vật thể 3D, cứ thêm vào w = 1, ta có (x, y, z, 1); xong truyền lên a_position, rồi nhân với u_projectionMatrix ra gl_Position = (x0, y0, z0, w) có w có thể khác 1, OpenGL ES sẽ tự động chuẩn hóa gl_Position bằng cách chia x0, y0, z0 cho w; ta có tọa độ 3D quen thuộc (x0/w, y0/w, z0/w) là ảnh của (x, y, z) sau phép biến đổi projection. Lời giải thích này ngầm chấp nhận w là hiển nhiên. Nhưng thực sự w là gì? Nó có vai trò gì? w = 1 có gì đặc biệt? Với w = 0 thì chuyện gì xảy ra (chia cho số 0)? Nếu w = 0.5 thì sao? Để có thể thỏa mãn những nỗi niềm trên, chúng ta cần phải tìm hiểu projective geometry. ","date":"May 15, 2015","objectID":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/:0:0","tags":["ProjectiveGeometry"],"title":"Hình học xạ ảnh P1","uri":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/"},{"categories":["Math"],"content":"Đôi nét về lịch sử Dürer is drawing a lute Sự việc bắt đầu từ thời Phục Hưng (thế kỷ 15) ở châu Âu, các họa sĩ lúc bấy giờ rất quan tâm đến việc làm sao để vẽ được một bức tranh trông như thật, tức là có perspective (nói cách khác là có chiều sâu). Là họa sĩ nhưng họ rất sẵn sàng “nghiên cứu khoa học” khi cần (thời xưa mà). Và hai trong số những họa sĩ tiêu biểu là Alberti (1404-1472) và Dürer (1471-1528), họ nhận ra rằng để một bức tranh có perspective, thì những đường thẳng song song ngoài đời thực khi vào tranh sẽ phải hội tụ tại một điểm gọi là vanishing point (điểm triệt tiêu); tập hợp tất cả những vanishing point này gọi là horizon line (đường chân trời) nằm ở ngang mắt người xem. Vanishing point and horizon line Quy luật này được trình bày trong bài luận Della Pictura của Alberti, có lẽ là một trong những luận thuyết đầu tiên về projective geometry: Perspective projection Những thế kỷ sau đó, các nhà toán học bắt tay vào nghiên cứu và xây dựng projective geometry một cách có hệ thống hơn. Đó là Desargues (1591-1661), người đầu tiên giới thiệu khái niệm điểm và đường thẳng ở vô tận. Tiếp nối là công lao của các nhà toán học như Pascal, Carnot, Monge… đã hoàn thiện một hệ thống nền tảng vững chắc cho projective geometry. ","date":"May 15, 2015","objectID":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/:0:1","tags":["ProjectiveGeometry"],"title":"Hình học xạ ảnh P1","uri":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/"},{"categories":["Math"],"content":"Hình học xạ ảnh là gì? Trước hết chúng ta sẽ bàn về mặt phẳng xạ ảnh (projective plane). Bạn đọc tinh ý sẽ nhận ra mặt phẳng xạ ảnh là mặt phẳng Euclid thêm vào những điểm ở vô tận và thêm một đường thẳng ở vô tận chứa hết những điểm vô tận ấy. Để hiểu hơn về những thứ vô tận này, chúng ta hãy cũng nhìn về vô tận dọc theo một hướng trên một đường thẳng. Một cách trực giác, ta nhận ra là sẽ có một điểm ở vô cùng xa, xa lắm, nếu đi theo hướng đó mãi mãi. Vậy nếu đi theo hướng ngược lại thì sao? Ta sẽ có một điểm vô tận khác chăng? Câu trả lời là không! Cả hai điểm thực chất là một, tức là, tất cả những đường thẳng song song với nhau theo cùng một phương sẽ có chung một và chỉ một điểm vô tận mà thôi. Không khó để nhận ra điều này, hãy nhìn vào hình vẽ ở trên và tưởng tượng: khi đường thẳng OX xoay quanh trục O, X đi ra xa dần, và đi tới vô tận khi OX song song mặt đường; tiếp tục xoay, ta thấy: X bỗng đâu xuất hiện từ đầu bên kia của đường thẳng! Chứng tỏ hai điểm ở vô tận thực chất là một. Cũng bằng trực giác, ta nhận ra những điểm vô tận này sẽ cùng nằm trên một đường thẳng, gọi là đường thẳng ở vô tận, bởi vì ảnh của chúng trên bức tranh cũng nằm trên một đường thẳng: horizon line. Có vẻ như sự thẳng hàng được bảo toàn? Chúng ta sẽ xem xét tính chất cực kỳ quan trọng này ở phần sau, khi nói về projective transformation. ","date":"May 15, 2015","objectID":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/:0:2","tags":["ProjectiveGeometry"],"title":"Hình học xạ ảnh P1","uri":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/"},{"categories":["Math"],"content":"Hệ thống tiên đề Với sự có mặt của điểm và đường thẳng ở vô tận, hai tiên đề căn bản của projective geometry được phát biểu rất tao nhã như sau: Qua hai điểm xác định duy nhất một đường thẳng. Qua hai đường thẳng xác định duy nhất một điểm. Quá đẹp! Không còn trường hợp song song ngoại lệ rất khó chịu của hình học Euclid. Bạn đọc thử nhẩm trong đầu xem hai tiên đề này có đúng hay không. Chưa hết đẹp! Trong các tiên đề / định lý của projective geometry, nếu ta hoán đổi “điểm” và “đường thẳng” thì tiên đề / định lý đó vẫn đúng. Tính chất này gọi là Duality. Duality sẽ làm ta thắc mắc: vậy rốt cục điểm là gì, đường thẳng là gì? Phải chăng đó chỉ đơn thuần là tên gọi? Nếu ta xây dựng được một hệ thống tập hợp mà mỗi phần tử là Dog hoặc Cat, và thỏa mãn: Qua hai Dog xác định duy nhất một Cat. Qua hai Cat xác định duy nhất một Dog. Thì hệ thống này cũng được gọi là projective geometry hỉ? Câu trả lời là… ở phần sau. ","date":"May 15, 2015","objectID":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/:0:3","tags":["ProjectiveGeometry"],"title":"Hình học xạ ảnh P1","uri":"/posts/2015/05-15-hinh-hoc-xa-anh-p1/"},{"categories":["Programming"],"content":"Các bài toán về thứ tự từ điển thì có cách giải thông thường là: viết ra giấy vài trường hợp, để ý phân tích, mò ra quy luật, từ đó có phương án implement tốt nhất. Xét ví dụ bài toán phát biểu như sau: Cho số nguyên dương n: Với dãy a là một hoán vị các số nguyên từ 1 đến n, hãy tính thứ tự từ điển của hoán vị này. Ngược lại, cho số tự nhiên k bé hơn n!, hãy tìm dãy a là hoán vị có số thứ tự k. Lưu ý là thứ tự bắt đầu tính từ 0. Trước hết là câu 1, giải thích qua ví dụ thì dễ dàng hơn, chẳng hạn với n = 5 và dãy a = [ 4, 5, 3, 1, 2 ]. Tư tưởng là đi đếm xem có bao nhiêu hoán vị bé hơn a. Những hoán vị bé hơn a dễ thấy nhất có dạng: [ 1, x, x, x, x ] [ 2, x, x, x, x ] [ 3, x, x, x, x ] trong đó mỗi dạng đều có số lượng hoán vị là 4! suy ra tổng cộng là 3 * 4! hoán vị. Bây giờ xét đến dạng [ 4, x, x, x, x ], bài toán có vẻ được lặp lại với kích thước giảm đi một đơn vị. Thật vậy, ta có thể bỏ số 4 để được dãy mới [ 5, 3, 1, 2 ] và quay lại cách tính như bước trên. Tuy nhiên có một điều cực kì quan trọng là trong dãy [ 5, 3, 1, 2 ] này, các số hạng không hề liên tiếp nhau: 1, 2, 3 rồi vọt lên 5. Do đó, ta phải quan niệm số 5 là số 4 mới được. Để khi đó sẽ xét tiếp các dạng: [ 1, x, x, x ] [ 2, x, x, x ] [ 3, x, x, x ] Nếu không quan niệm 5 là 4 ta sẽ vô tình xét thêm dạng [ 4, x, x, x ] dẫn đến kết quả sai. Để biết phải quan niệm số 5 là số mấy, đơn giản đếm xem trong dãy [ 5, 3, 1, 2 ] có bao nhiêu số bé hơn 5. Câu 2 suy ngược lại từ câu 1, vẫn lấy ví dụ n = 5, nhận xét rằng các hoán vị sẽ được sắp theo kiểu: 4! các hoán vị dạng [ 1, x, x, x, x ] 4! các hoán vị dạng [ 2, x, x, x, x ] 4! các hoán vị dạng [ 3, x, x, x, x ] 4! các hoán vị dạng [ 4, x, x, x, x ] 4! các hoán vị dạng [ 5, x, x, x, x ] Để tính phần tử đầu tiên của a, ta sẽ tìm xem dãy a thuộc dạng nào trong 5 dạng trên, chỉ cần lấy thương trong phép chia k cho 4!. Để tính phần tử tiếp theo của a, ta lại đi sâu vào dạng mới tìm được với số thứ tự là số dư trong phép chia k cho 4!. Cứ thế cho đến khi tính được phần tử cuối cùng của a. Code minh họa: #include \u003cstdio.h\u003e #include \u003cconio.h\u003e #include \u003cstdlib.h\u003e unsigned long gt[13]; void tinhgt() { gt[0] = 1; for (unsigned long i = 1; i \u003c 13; i++) gt[i] = gt[i - 1] * i; } unsigned long thutu(int* a, int n) { unsigned long s = 0, i, j, k; for (i = 1; i \u003c= n; i++) { j = 0; for (k = i + 1; k \u003c= n; k++) if (a[k] \u003c a[i]) j++; s += gt[n - i] * j; } return s + 1; } int* timday(unsigned long s, int n) { int* a = (int*)malloc(sizeof(int) * (n + 1)); int* cx = (int*)malloc(sizeof(int) * (n + 1)); int i, j, t; for (i = 1; i \u003c= n; i++) cx[i] = 1; for (i = 1; i \u003c= n; i++) { t = (s - 1) / gt[n - i] + 1; for (j = 1; j \u003c= n; j++) if (cx[j]) { t--; if (t == 0) { a[i] = j; cx[j] = 0; break; } } s = (s - 1) % gt[n - i] + 1; } return a; } void main() { tinhgt(); clrscr(); int i, n, a[13]; printf(\"Nhap so nguyen duong \u003c= 12, n = \"); scanf(\"%d\", \u0026n); printf(\"\\nCau a:\\n\"); for (i = 1; i \u003c= n; i++) { printf(\"Nhap a[%d] = \", i); scanf(\"%d\", \u0026a[i]); } printf(\"Ket qua = %lu\", thutu(a, n)); unsigned long s; printf(\"\\n\\nCau b:\\n\"); printf(\"Nhap so nguyen duong \u003c= %lu, s = \", gt[n]); scanf(\"%lu\", \u0026s); printf(\"Ket qua: \"); int* b; b = timday(s, n); for (i = 1; i \u003c= n; i++) printf(\"%d \", b[i]); getch(); } 2023/05/07 – Cập nhật code minh họa F# thần chưởng: let maxN = 10 let gt = Array.create maxN 1 for n = 1 to gt.Length-1 do gt[n] \u003c- gt[n-1] * n let count predicate = Seq.filter predicate \u003e\u003e Seq.length let (\u003c/\u003e) a b = a / b, a % b let rec orderOf = function | [] -\u003e 0 | head :: tail -\u003e (tail |\u003e count ((\u003e)head)) * gt[tail.Length] + orderOf tail let listAt n order = let rec loop n order tokens = if n = 0 then [] else let i, order = order \u003c/\u003e gt[n-1] (tokens |\u003e List.item i) :: loop (n-1) order (tokens |\u003e List.removeAt i) loop n order [1..n] // Test: orderOf [ 4; 5; 3; 1; 2 ] // 94 listAt 5 94 // [ 4; 5; 3; 1; 2 ] ","date":"September 29, 2008","objectID":"/posts/2008/09-29-thu-tu-tu-dien/:0:0","tags":["Algorithm"],"title":"Thứ tự từ điển","uri":"/posts/2008/09-29-thu-tu-tu-dien/"}]