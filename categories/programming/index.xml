<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Programming - Category - Nghia Bui</title><link>/categories/programming/</link><description>Programming - Category - Nghia Bui</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 30 Nov 2017 00:00:00 +0000</lastBuildDate><atom:link href="/categories/programming/" rel="self" type="application/rss+xml"/><item><title>Some thoughts on monads</title><link>/posts/2017/11-30-some-thoughts-on-monads/</link><pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2017/11-30-some-thoughts-on-monads/</guid><description>I know, I know, the world does not need yet another explanation on monads. There have been a lot of related articles you can find on the Internet. Still, most of them are so math-intensive that we as software developers (we aren&amp;rsquo;t good at math) don&amp;rsquo;t want to read. So please give me a try to explain monads to you. I think they are worth knowing about. No math knowledge is required.</description></item><item><title>Null References: The Billion Dollar Mistake</title><link>/posts/2016/08-03-null-references-the-billion-dollar-mistake/</link><pubDate>Wed, 03 Aug 2016 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2016/08-03-null-references-the-billion-dollar-mistake/</guid><description>Null is clearly evil. We as human tend to forget to check null, and boom&amp;hellip; crash!!! Documentation may help, but again we still forget reading documents. Worse, not all documents are correct and up-to-date 100%. Even if we remember to do every null check, our code would be very messy.
So what is the solution?
Checked-exceptions can help but must be used with care otherwise nearly every function/method in our programs could throw checked-exceptions, and try/catch statements would appear everywhere.</description></item><item><title>How do you use Exceptions?</title><link>/posts/2016/07-16-how-do-you-use-exceptions/</link><pubDate>Sat, 16 Jul 2016 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2016/07-16-how-do-you-use-exceptions/</guid><description>Exceptions are a very common concept in most of languages nowadays. In this article we will discuss why exceptions are needed, checked vs. unchecked exceptions, and why C# doesn&amp;rsquo;t have checked exceptions.
In the old days, defensive code were a mess Before exceptions were invented, defensive code had been overwhelmed with a lot of error checking and recovery from those errors, for example:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void handle() { // style #1: error is embedded in the return value int errFoo = foo(); if (errFoo == -1) { // recovery and may return } // style #2: error is assigned to the output parameter unsigned int errBar; int value = bar(.</description></item><item><title>How to think about MVC, MVP, PM, and MVVM?</title><link>/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/</link><pubDate>Thu, 17 Mar 2016 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/</guid><description>This article is about my personal explanation of the famous design patterns: Model View Controller (MVC), Model View Presenter (MVP), Presentation Model (PM), and Model View ViewModel (MVVM).
Let&amp;rsquo;s start with Model.
Model: the core of an application At the core of an application is a component called Model where business objects and use-case objects live. Normally, the outside world interacts with the Model by sending input to the use-case objects, these objects then manipulate the business ones and finally return output back to the outside world.</description></item><item><title>GoF Builder Pattern</title><link>/posts/2016/03-14-gof-builder-pattern/</link><pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2016/03-14-gof-builder-pattern/</guid><description>Builder Pattern and Factory Pattern are pretty similar in a way: both of them encapsulate the details of object-creation processes. However, in cases there are many complicated processes to create various representations of objects, and those processes share a common trait, Builder Pattern is the better choice.
Let&amp;rsquo;s say we have two processes to build a house: Asian process and European one. We will start with Factory Pattern and gradually adapt it to Builder Pattern.</description></item><item><title>OOP vs. ECS</title><link>/posts/2016/01-26-oop-vs-ecs/</link><pubDate>Tue, 26 Jan 2016 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2016/01-26-oop-vs-ecs/</guid><description>In recent years, Entity-Component System (ECS) has been recognized as the most notable architecture for game development. There are many good articles about the architecture that can be found on the Internet, some of them are:
Entity Systems are the future of MMOG development What is an entity system framework for game development? Why use an entity system framework for game development? Understanding Component-Entity-Systems gamedev.stackexchange.com Entity Systems Wiki Entity component system Of course these articles are excellent and well-written, but one thing I don&amp;rsquo;t like about them is that they are not fair at comparing OOP and ECS.</description></item><item><title>Imperative vs. Declarative</title><link>/posts/2015/11-11-imperative-vs-declarative/</link><pubDate>Wed, 11 Nov 2015 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2015/11-11-imperative-vs-declarative/</guid><description>Wikipedia defines imperative and declarative programming as:
imperative programming is a style that uses statements that change a program’s state&amp;hellip; focuses on describing HOW a program operates.
declarative programming is a style that expresses the logic of a computation without describing its control flow&amp;hellip; focuses on describing WHAT the program should accomplish in terms of the problem domain.
When we read the definition of something, we tend to focus on terms that are already familiar to us, and then use those terms as a metaphor in order to understand the definition.</description></item><item><title>Thứ tự từ điển</title><link>/posts/2008/09-29-thu-tu-tu-dien/</link><pubDate>Mon, 29 Sep 2008 00:00:00 +0000</pubDate><author>Nghia</author><guid>/posts/2008/09-29-thu-tu-tu-dien/</guid><description>Các bài toán về thứ tự từ điển thì có cách giải thông thường là: viết ra giấy vài trường hợp, để ý phân tích, mò ra quy luật, từ đó có phương án implement tốt nhất.
Xét ví dụ bài toán phát biểu như sau:
Cho số nguyên dương n:
Với dãy a là một hoán vị các số nguyên từ 1 đến n, hãy tính thứ tự từ điển của hoán vị này.</description></item></channel></rss>