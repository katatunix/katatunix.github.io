<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>DesignPattern - Tag - Nghia Bui</title><link>/tags/designpattern/</link><description>DesignPattern - Tag - Nghia Bui</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 30 Nov 2017 00:00:00 +0000</lastBuildDate><atom:link href="/tags/designpattern/" rel="self" type="application/rss+xml"/><item><title>Some thoughts on monads</title><link>/posts/2017/11-30-some-thoughts-on-monads/</link><pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate><author>xxxx</author><guid>/posts/2017/11-30-some-thoughts-on-monads/</guid><description><![CDATA[<p>I know, I know, the world does not need yet another explanation on monads. There have been a lot of related articles you can find on the Internet. Still, most of them are so math-intensive that we as software developers (we aren&rsquo;t good at math) don&rsquo;t want to read. So please give me a try to explain monads to you. I think they are worth knowing about. No math knowledge is required. What I want from you is just a basic knowledge of programming with types and functions.</p>]]></description></item><item><title>How to think about MVC, MVP, PM, and MVVM?</title><link>/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/</link><pubDate>Thu, 17 Mar 2016 00:00:00 +0000</pubDate><author>xxxx</author><guid>/posts/2016/03-17-how-to-think-about-mvc-mvp-pm-and-mvvm/</guid><description><![CDATA[<p>This article is about my personal explanation of the famous design patterns: Model View Controller (MVC), Model View Presenter (MVP), Presentation Model (PM), and Model View ViewModel (MVVM).</p>
<p>Let&rsquo;s start with Model.</p>
<h2 id="model-the-core-of-an-application">Model: the core of an application</h2>
<p>At the core of an application is a component called Model where <em>business objects</em> and <em>use-case objects</em> live. Normally, the outside world interacts with the Model by sending input to the use-case objects, these objects then manipulate the business ones and finally return output back to the outside world.</p>]]></description></item><item><title>GoF Builder Pattern</title><link>/posts/2016/03-14-gof-builder-pattern/</link><pubDate>Mon, 14 Mar 2016 00:00:00 +0000</pubDate><author>xxxx</author><guid>/posts/2016/03-14-gof-builder-pattern/</guid><description><![CDATA[<p>Builder Pattern and Factory Pattern are pretty similar in a way: both of them encapsulate the details of object-creation processes. However, in cases there are many complicated processes to create various representations of objects, and those processes share a common trait, Builder Pattern is the better choice.</p>
<p>Let&rsquo;s say we have two processes to build a house: Asian process and European one. We will start with Factory Pattern and gradually adapt it to Builder Pattern. A possible implementation of Factory Pattern could be:</p>]]></description></item></channel></rss>